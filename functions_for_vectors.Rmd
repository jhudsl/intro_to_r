---
title: "Functions that need pull first"
output: 
  html_document:
    toc: TRUE
---

When can you use a function directly on a column of a tibble and when do you need a vector in R?

There are some inconsistencies across different functions. Typically if it is a base R function, you often need to pull the data out into a vector first.  Sometimes you just need to try them out. Always check that your work did what you expect!

## In general

In general these are the conventions for working with values (recall that values or samples within rows):

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(kableExtra)
library(tidyverse)
text_tbl <- data.frame(
  Type = c("base R and tidyverse function", "special tidyverse functions", "base R functions", "stat functions that come with R"),
  Example = c("setdiff()", "stringr functions like str_replace()", "mean()", "cor.test()"))
kbl(text_tbl) %>%
  # kable_classic(full_width = F, html_font = "helvetica") %>%
  kable_paper(full_width = F, html_font = "helvetica", font_size = "18") %>%
  column_spec(1:2, bold = T, border_right = T, border_left = TRUE) %>%
  row_spec(0, align = "c") %>%
  row_spec(1, background = "yellow") %>%
  row_spec(2, background = "lightgreen") %>%
  row_spec(3:4, background = "lightblue")
```

## `setdiff()`

This function was originally a base R function and it got adopted by tidyverse packages (`dplyr` and `lubridate`) and is therefore can behave a bit differently.



```{r}
animal1 <-tibble(animals = c("cat", "dog", "mouse"), 
                 size  = c("medium", "medium", "small"))
animal2 <-tibble(animals = c("cat", "hourse", "fish"),
                 size  = c("medium", "large", "small"))

# shows what is in the first data set that is not in the second dataset as a tibble
dplyr::setdiff(select(animal1, animals), 
               select(animal2, animals))
# shows what is in the first data set that is not in the second dataset as a vector
dplyr::setdiff(pull(animal1, animals), 
               pull(animal2, animals))
# shows what is in the first data set that is not in the second dataset as a vector
base::setdiff(animal1$animals, 
               animal2$animals)
# shows what is in the first data set that is not in the second dataset as a vector
base::setdiff(pull(animal1,animals), 
              pull(animal2,animals))

base::setdiff(select(animal1, animals), 
              select(animal2, animals)) # works a bit differently

lubridate::setdiff(select(animal1, animals), 
              select(animal2, animals)) 
```

- `setdiff()` is both a base R and `dplyr` function. This is confusing and part of the struggle of an open development environment.
- When using `setdiff()` from base R, vectors are required. It shows the elements in the first that are missing from the second.


```{r}
data_As <- tibble(State = c("Alabama", "Alaska"),
                 state_bird = c("wild turkey", "willow ptarmigan"))
data_cold <- tibble(State = c("Maine", "Alaska", "Alaska"),
                    vacc_rate = c(0.795, 0.623, 0.626),
                    month = c("April", "April", "May"))

A_states <- data_As %>% pull(State)
cold_states <- data_cold %>% pull(State)
setdiff(A_states, cold_states)

```

When using `setdiff()` from `dplyr`, it does something different. It tells us the rows in the first tibble that are not in the second tibble. We have to select “State” column so the columns are identical across the two tibbles.

```{r}
A_states <- data_As %>% select(State)
cold_states <- data_cold %>% select(State)
dplyr::setdiff(A_states, cold_states)
```

We could also use `setdiff()` from `dplyr` to tell us what rows were removed when filtering a dataframe or tibble:

```{r}
mt_cars_high_mpg <- mtcars %>% filter(mpg > 20)
dplyr::setdiff(mtcars, mt_cars_high_mpg)
```


## `stringr` functions

These functions are often applied within `filter()` or `mutate()` for a data frame. When they are not used inside these functions they need to be used on a vector. 

```{r}
iris %>% filter(str_detect(string = Species, pattern = "set")) %>% head() # this will work

iris %>% pull(Species) %>% str_detect(pattern = "set") %>% head() # so will this
```

```{r}
iris %>% pull(Species) %>% str_detect(pattern = "set")

```
